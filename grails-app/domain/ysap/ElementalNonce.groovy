package ysap

class ElementalNonce {
    String nonceName        // Unique identifier for the nonce
    String nonceValue       // The actual nonce string (hexadecimal or encoded)
    String elementType      // AIR, FIRE, EARTH, WATER
    String chemicalClue     // Randomized digital specification clue
    String commandFlag      // The flag needed for execution (e.g., "--decode", "--unlock")
    String description      // Flavor text about the nonce
    Boolean isDiscovered = false
    Date discoveredDate
    Integer matrixLevel     // Which level this nonce can be found on
    Integer mapNumber       // Which map (1-10) this nonce belongs to
    String gameSessionId    // Which game session this belongs to
    String discoveryMethod  // HOW this nonce is found: DEFRAG_REWARD, PUZZLE_ROOM, MERCHANT, FRAGMENT_EXECUTION
    
    // Location where this nonce can be discovered
    Integer sourceX
    Integer sourceY
    String sourceDescription  // Additional context about where/how to find it
    
    static constraints = {
        nonceName blank: false, maxSize: 50
        nonceValue blank: false, maxSize: 100
        elementType inList: ['AIR', 'FIRE', 'EARTH', 'WATER']
        chemicalClue blank: false, maxSize: 200
        commandFlag blank: false, maxSize: 50
        description blank: false, maxSize: 500
        matrixLevel min: 1, max: 10
        mapNumber min: 1, max: 10
        gameSessionId blank: false, maxSize: 50
        discoveryMethod inList: ['DEFRAG_REWARD', 'PUZZLE_ROOM', 'MERCHANT', 'FRAGMENT_EXECUTION', 'HIDDEN_CACHE']
        discoveredDate nullable: true
        sourceX min: 0, max: 9, nullable: true
        sourceY min: 0, max: 9, nullable: true
        sourceDescription nullable: true, maxSize: 300
    }
    
    static mapping = {
        description type: 'text'
        chemicalClue type: 'text'
        sourceDescription type: 'text'
        // Composite index for session/map queries
        gameSessionId index: 'nonce_session_idx'
        mapNumber index: 'nonce_session_idx'
    }
    
    String toString() {
        return "${nonceName} (${elementType}) - ${isDiscovered ? 'DISCOVERED' : 'HIDDEN'}"
    }
    
    // Helper methods
    String getElementIcon() {
        switch(elementType) {
            case 'AIR': return 'üúÅ'
            case 'FIRE': return 'üúÇ'
            case 'EARTH': return 'üúÉ'
            case 'WATER': return 'üúÑ'
            default: return '‚ùì'
        }
    }
    
    String getChemicalHint() {
        return "${getElementIcon()} Digital signature: ${chemicalClue}"
    }
    
    String getExecutionCommand() {
        return "execute ${commandFlag} ${nonceValue}"
    }
    
    Boolean matchesElement(String targetElement) {
        return elementType.equalsIgnoreCase(targetElement)
    }
    
    String getDiscoveryHint() {
        switch(discoveryMethod) {
            case 'DEFRAG_REWARD':
                return "Found by defeating high-level defrag bots"
            case 'PUZZLE_ROOM':
                return "Hidden in a special puzzle room"
            case 'MERCHANT':
                return "Available from rare merchants"
            case 'FRAGMENT_EXECUTION':
                return "Generated by executing special logic fragments"
            case 'HIDDEN_CACHE':
                return "Concealed in coordinate caches"
            default:
                return "Discovery method unknown"
        }
    }
}